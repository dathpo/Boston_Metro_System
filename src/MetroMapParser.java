import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;
import java.util.StringTokenizer;

/**
 * This class reads a text description of a metro subway system and generates a
 * graph representation of the metro.
 * <p>
 * Students should feel free to modify this code as needed to complete this
 * exercise.
 *
 * <p>
 * <p>
 * The grammar for the file is described below in BNF. A typical line in the
 * file looks like this :
 *
 * <code> 20 NorthStation   Green 19 22  Orange 15 22  </code>
 * <p>
 * where : 20 is the StationID NorthStation is the StationName Green 19 22 Green
 * is the LineName 19 is the StationID of the outbound station 22 is the
 * StationID of the inbound station Orange 15 22 is a LineID in which : Orange
 * is the LineName 15 is the StationID of the outbound station 22 is the
 * StationID of the inbound station
 * <p>
 * Therefore, NorthStation has two outgoing lines.
 * <p>
 * note : 0 denotes the end of a line : i.e. in this case, OakGrove would be at
 * the end of the line, as there is no other outbound station.
 *
 * <p>
 * metro-map ::= station-spec* <BR>
 * station-spec ::= station-id station-name station-line+ <BR>
 * station-id ::= (positive integer) <BR>
 * station-name ::= string <BR>
 * station-line ::= line-name station-id station-id <BR>
 */

public class MetroMapParser {

    private BufferedReader fileInput;

    public static void main(String[] args) {
        String filename = "bostonmetro.txt";
        Metro map = new Metro();
        try {
            MetroMapParser mmp = new MetroMapParser(filename);
            MetroMapParser mmp2 = new MetroMapParser(filename);
            mmp.parseStations(map);
            mmp2.parseLines(map);
        } catch (Exception e) {
            e.printStackTrace();
        }
        Scanner input = new Scanner(System.in);
        String start = "a", end = "b";
        int startID = 0;
        int endID = 0;
        while (!(map.stationNames.contains(start))) {
            System.out.println("Please enter your start station:");
            start = input.next();
            if (start.equals("St.PaulStreet")) {
                startID = map.checkDouble();
            } else if (startID == 0) {
                startID = map.stationNames.indexOf(start);
            }
        }
        while (!(map.stationNames.contains(end))) {
            System.out.println("Please enter your end station:");
            end = input.next();
            if (end.equals("St.PaulStreet")) {
                endID = map.checkDouble();
            } else if (endID == 0) {
                endID = map.stationNames.indexOf(end);
            }
        }
        for (int i = 0; i < map.stationNames.size(); i++) {
            if (map.stationNames.get(i).equals(start)) {
                startID = i + 1;
            }
            if (map.stationNames.get(i).equals(end)) {
                endID = i + 1;
            }
        }
        map.findRoute(startID, endID);
    }

    /**
     * @throws java.io.IOException if there <tt>filename</tt> cannot be read
     * @effects: creates a new parser that will read from the file filename
     * unless the file does not exist. The filename should specify the
     * exact location of the file. This means it should be something
     * like /mit/$USER/6.170/ex3/bostonmetro.txt
     * @returns a new MetroMapParser that will parse the file filename
     */

    public MetroMapParser(String filename) throws IOException {
        // a buffered reader reads line by line, returning null when file is
        // done
        fileInput = new BufferedReader(new FileReader(filename));
    }

    /**
     * @throws java.io.IOException  if there is a problem reading the file
     * @throws ex3.BadFileException if there is a problem with the format of the file
     * @effects: parses the file, and generates a graph from it, unless there is
     * a problem reading the file, or there is a problem with the
     * format of the file.
     * @returns the Graph generated by the file
     */

    public void parseStations(Metro map) throws IOException, BadFileException {
        String line = fileInput.readLine();
        StringTokenizer st;
        String stationID;
        String stationName;
        String lineName;
        String outboundID, inboundID;
        map.addStationInfo(0, "Dummy");
        // Setting first value of arrayList to dummy 0 value to maintain
        // consistency between station names index and station IDs.
        while (line != null) {
            // STUDENT :
            //
            // in this loop, you must collect the information necessary to
            // construct your graph, and you must construct your graph as well.
            // how and where you do this will depend on the design of your
            // graph.
            //
            // StringTokenizer is a java.util Class that can break a string into
            // tokens
            // based on a specified delimiter. The default delimiter is "
            // \t\n\r\f" which
            // corresponds to the space character, the tab character, the
            // newline character,
            // the carriage-return character and the form-feed character.
            st = new StringTokenizer(line);
            // We want to handle empty lines effectively, we just ignore them!
            if (!st.hasMoreTokens()) {
                line = fileInput.readLine();
                continue;
            }
            // from the grammar, we know that the Station ID is the first token
            // on the line
            stationID = st.nextToken();
            int stationIDInt = Integer.parseInt(stationID);
            if (!st.hasMoreTokens()) {
                throw new BadFileException("no station name");
            }
            // from the grammar, we know that the Station Name is the second
            // token on the line.
            stationName = st.nextToken();
            map.stationNames.add(stationName);
            map.addStationInfo(stationIDInt, stationName);
            if (!st.hasMoreTokens()) {
                throw new BadFileException("station is on no lines");
            }
            while (st.hasMoreTokens()) {
                st.nextToken();
                if (!st.hasMoreTokens()) {
                    throw new BadFileException("poorly formatted line info");
                }
                st.nextToken();
                if (!st.hasMoreTokens()) {
                    throw new BadFileException("poorly formatted adjacent stations");
                }
                st.nextToken();
            }
            line = fileInput.readLine();
        }
    }

    public void parseLines(Metro map) throws IOException, BadFileException {
        String line = fileInput.readLine();
        StringTokenizer st;
        String stationID;
        String stationName;
        String lineName;
        String outboundID, inboundID;
        // Setting first value of arrayList to dummy 0 value to maintain
        // consistency between station names index and station IDs.
        while (line != null) {
            // STUDENT :
            //
            // in this loop, you must collect the information necessary to
            // construct your graph, and you must construct your graph as well.
            // how and where you do this will depend on the design of your
            // graph.
            //
            // StringTokenizer is a java.util Class that can break a string into
            // tokens
            // based on a specified delimiter. The default delimiter is "
            // \t\n\r\f" which
            // corresponds to the space character, the tab character, the
            // newline character,
            // the carriage-return character and the form-feed character.
            st = new StringTokenizer(line);
            // We want to handle empty lines effectively, we just ignore them!
            if (!st.hasMoreTokens()) {
                line = fileInput.readLine();
                continue;
            }
            // from the grammar, we know that the Station ID is the first token
            // on the line
            stationID = st.nextToken();
            int stationIDInt = Integer.parseInt(stationID);
            if (!st.hasMoreTokens()) {
                throw new BadFileException("no station name");
            }
            // from the grammar, we know that the Station Name is the second
            // token on the line.
            st.nextToken();
            if (!st.hasMoreTokens()) {
                throw new BadFileException("station is on no lines");
            }
            while (st.hasMoreTokens()) {
                lineName = st.nextToken();
                if (!st.hasMoreTokens()) {
                    throw new BadFileException("poorly formatted line info");
                }
                inboundID = st.nextToken();
                if (!st.hasMoreTokens()) {
                    throw new BadFileException("poorly formatted adjacent stations");
                }
                outboundID = st.nextToken();
                int inboundIDInt = Integer.parseInt(inboundID);
                int outboundIDInt = Integer.parseInt(outboundID);
                map.addLine(stationIDInt, inboundIDInt, lineName);
                map.addLine(stationIDInt, outboundIDInt, lineName);
            }
            line = fileInput.readLine();
        }
    }
}
